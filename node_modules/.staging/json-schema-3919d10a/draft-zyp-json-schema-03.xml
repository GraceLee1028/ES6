<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc4287 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4287.xml">
<!ENTITY rfc2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY rfc3339 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY rfc2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY rfc5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY rfc2396 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2396.xml">
<!ENTITY iddiscovery SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hammer-discovery.xml">
<!ENTITY uritemplate SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.gregorio-uritemplate.xml">
<!ENTITY linkheader SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.nottingham-http-link-header.xml">
<!ENTITY html401 SYSTEM "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml">
<!ENTITY css21 SYSTEM "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-CSS21-20070719.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<rfc category="info" docName="draft-zyp-json-schema-03" ipr="trust200902">
	<front>
		<title abbrev="JSON Schema Media Type">A JSON Media Type for Describing the Structure and Meaning of JSON Documents</title>
		
		<author fullname="Kris Zyp" initials="K" role="editor" surname="Zyp">
			<organization>SitePen (USA)</organization>
			<address>
				<postal>
					<street>530 Lytton Avenue</street>
					<city>Palo Alto, CA 94301</city>
					<country>USA</country>
				</postal>
				<phone>+1 650 968 8787</phone>
				<email>kris@sitepen.com</email>
			</address>
		</author>
		
		<author fullname="Gary Court" initials="G" surname="Court">
			<address>
				<postal>
					<street></street>
					<city>Calgary, AB</city>
					<country>Canada</country>
				</postal>
				<email>gary.court@gmail.com</email>
			</address>
		</author>
		
		<date year="2011" />
		<workgroup>Internet Engineering Task Force</workgroup>
		<keyword>JSON</keyword>
		<keyword>Schema</keyword>
		<keyword>JavaScript</keyword>
		<keyword>Object</keyword>
		<keyword>Notation</keyword>
		<keyword>Hyper Schema</keyword>
		<keyword>Hypermedia</keyword>
		
		<abstract>
			<t>
				JSON (JavaScript Object Notation) Schema defines the media type "application/schema+json", 
				a JSON based format for defining 
				the structure of JSON data. JSON Schema provides a contract for what JSON 
				data is required for a given application and how to interact with it. JSON 
				Schema is intended to define validation, documentation, hyperlink 
				navigation, and interaction control of JSON data. 
			</t>
		</abstract>
	</front>
	
	<middle>
		<section title="Introduction">
			<t>
				JSON (JavaScript Object Notation) Schema is a JSON media type for defining 
				the structure of JSON data. JSON Schema provides a contract for what JSON 
				data is required for a given application and how to interact with it. JSON 
				Schema is intended to define validation, documentation, hyperlink 
				navigation, and interaction control of JSON data. 
			</t>
		</section>
		
		<section title="Conventions">
			<t>
				<!-- The text in this section has been copied from the official boilerplate, 
				and should not be modified.-->
				
				The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", 
				"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
				interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
			</t>
		</section>
		
		<!-- ********************************************* -->
		
		<section title="Overview">
			<t>
				JSON Schema defines the media type "application/schema+json" for 
				describing the structure of other
				JSON documents. JSON Schema is JSON-based and includes facilities 
				for describing the structure of JSON documents in terms of
				allowable values, descriptions, and interpreting relations with other resources.
			</t>
			<t>
				JSON Schema format is organized into several separate definitions. The first 
				definition is the core schema specification. This definition is primary 
				concerned with describing a JSON structure and specifying valid elements
				in the structure. The second definition is the Hyper Schema specification
				which is intended define elements in a structure that can be interpreted as
				hyperlinks.
				Hyper Schema builds on JSON Schema to describe the hyperlink structure of 
				other JSON documents and elements of interaction. This allows user agents to be able to successfully navigate
				JSON documents based on their schemas.
			</t>
			<t>
				Cumulatively JSON Schema acts as a meta-document that can be used to define the required type and constraints on
				property values, as well as define the meaning of the property values
				for the purpose of describing a resource and determining hyperlinks
				within the representation. 
			</t>
			<figure>
				<preamble>An example JSON Schema that describes products might look like:</preamble>
				<artwork>
<![CDATA[	
{
	"title": "Product",
	"properties": {
		"id": {
			"type": "number",
			"description": "Product identifier",
			"required": true
		},
		"name": {
			"description": "Name of the product",
			"type": "string",
			"required": true
		},
		"price": {
			"required": true,
			"type": "number",
			"minimum": 0,
			"required": true
		},
		"tags": {
			"type": "array",
			"items": {
				"type": "string"
			}
		}
	},
	"links": [{
		"rel": "full",
		"href": "{id}"
	}, {
		"rel": "comments",
		"href": "comments/?id={id}"
	}]
}
]]>
				</artwork>
				<postamble>
					This schema defines the properties of the instance JSON documents, 
					the required properties (id, name, and price), as well as an optional
					property (tags). This also defines the link relations of the instance
					JSON documents.
				</postamble>
			</figure>
			
			<section title="Terminology">
				<t>
					For this specification, <spanx style="strong">schema</spanx> will be used to denote a JSON Schema 
					definition, and an <spanx style="strong">instance</spanx> refers to a JSON value that the schema 
					will be describing and validating.
				</t>
			</section>
			
			<section title="Design Considerations">
				<t>
					The JSON Schema media type does not attempt to dictate the structure of JSON
					representations that contain data, but rather provides a separate format
					for flexibly communicating how a JSON representation should be
					interpreted and validated, such that user agents can properly understand
					acceptable structures and extrapolate hyperlink information
					with the JSON document. It is acknowledged that JSON documents come
					in a variety of structures, and JSON is unique in that the structure
					of stored data structures often prescribes a non-ambiguous definite
					JSON representation. Attempting to force a specific structure is generally
					not viable, and therefore JSON Schema allows for a great flexibility
					in the structure of the JSON data that it describes.
				</t>
				<t>
					This specification is protocol agnostic.
					The underlying protocol (such as HTTP) should sufficiently define the
					semantics of the client-server interface, the retrieval of resource
					representations linked to by JSON representations, and modification of 
					those resources. The goal of this
					format is to sufficiently describe JSON structures such that one can
					utilize existing information available in existing JSON
					representations from a large variety of services that leverage a representational state transfer
					architecture using existing protocols.
				</t>
			</section>
		</section>
		
		<section title="Schema/Instance Association">
			<t>
				JSON Schema instances are correlated to their schema by the "describedby"
				relation, where the schema is defined to be the target of the relation.
				Instance representations may be of the "application/json" media type or
				any other subtype. Consequently, dictating how an instance
				representation should specify the relation to the schema is beyond the normative scope
				of this document (since this document specifically defines the JSON
				Schema media type, and no other), but it is recommended that instances
				specify their schema so that user agents can interpret the instance
				representation and messages may retain the self-descriptive
				characteristic, avoiding the need for out-of-band information about
				instance data. Two approaches are recommended for declaring the
				relation to the schema that describes the meaning of a JSON instance's (or collection 
				of instances) structure. A MIME type parameter named
				"profile" or a relation of "describedby" (which could be defined by a Link header) may be used:
				
				<figure>
					<artwork>
<![CDATA[	
Content-Type: application/my-media-type+json;
              profile=http://json.com/my-hyper-schema
]]>
					</artwork>
				</figure>
				
				or if the content is being transferred by a protocol (such as HTTP) that
				provides headers, a Link header can be used:
				
				<figure>
					<artwork>
<![CDATA[
Link: <http://json.com/my-hyper-schema>; rel="describedby"
]]>
					</artwork>
				</figure>
				
				Instances MAY specify multiple schemas, to indicate all the schemas that 
				are applicable to the data, and the data SHOULD be valid by all the schemas. 
				The instance data MAY have multiple schemas 
				that it is defined by (the instance data SHOULD be valid for those schemas). 
				Or if the document is a collection of instances, the collection MAY contain 
				instances from different schemas. When collections contain heterogeneous 
				instances, the "pathStart" attribute MAY be specified in the 
				schema to disambiguate which schema should be applied for each item in the 
				collection. However, ultimately, the mechanism for referencing a schema is up to the
				media type of the instance documents (if they choose to specify that schemas
				can be referenced).
			</t>
			
			<section title="Self-Descriptive Schema">
				<t>
					JSON Schemas can themselves be described using JSON Schemas. 
					A self-describing JSON Schema for the core JSON Schema can
					be found at <eref target="http://json-schema.org/schema">http://json-schema.org/schema</eref> for the latest version or 
					<eref target="http://json-schema.org/draft-03/schema">http://json-schema.org/draft-03/schema</eref> for the draft-03 version. The hyper schema 
					self-description can be found at <eref target="http://json-schema.org/hyper-schema">http://json-schema.org/hyper-schema</eref> 
					or <eref target="http://json-schema.org/draft-03/hyper-schema">http://json-schema.org/draft-03/hyper-schema</eref>. All schemas
					used within a protocol with media type definitions
					SHOULD include a MIME parameter that refers to the self-descriptive
					hyper schema or another schema that extends this hyper schema:
					
					<figure>
						<artwork>
<![CDATA[	
Content-Type: application/json; 
              profile=http://json-schema.org/draft-03/hyper-schema
]]>
						</artwork>
					</figure>
				</t>
			</section>
		</section>
		
		<section title="Core Schema Definition">
			<t>
				A JSON Schema is a JSON Object that defines various attributes 
				(including usage and valid values) of a JSON value. JSON
				Schema has recursive capabilities; there are a number of elements
				in the structure that allow for nested JSON Schemas.
			</t>
			
			<figure>
				<preamble>An example JSON Schema definition could look like:</preamble>
				<artwork>
<![CDATA[
{
	"description": "A person",
	"type": "object",

	"properties": {
		"name": {
			"type": "string"
		},
		"age": {
			"type": "integer",
			"maximum": 125
		}
	}
}
]]>
				</artwork>
			</figure>
			
			<t>
				A JSON Schema object may have any of the following properties, called schema
				attributes (all attributes are optional):
			</t>
			
			<section title="type">
				<t>
					This attribute defines what the primitive type or the schema of the instance MUST be in order to validate. 
					This attribute can take one of two forms:

					<list style="hanging">
						<t hangText="Simple Types">
							A string indicating a primitive or simple type. The following are acceptable string values:

							<list style="hanging">
								<t hangText="string">Value MUST be a string.</t>
								<t hangText="number">Value MUST be a number, floating point numbers are allowed. </t>
								<t hangText="integer">Value MUST be an integer, no floating point numbers are allowed. This is a subset of the number type.</t>
								<t hangText="boolean">Value MUST be a boolean. </t>
								<t hangText="object">Value MUST be an object.</t>
								<t hangText="array">Value MUST be an array.</t>
								<t hangText="null">Value MUST be null. Note this is mainly for purpose of being able use union types to define nullability. If this type is not included in a union, null values are not allowed (the primitives listed above do not allow nulls on their own).</t>
								<t hangText="any">Value MAY be of any type including null.</t>
							</list>
							
							If the property is not defined or is not in this list, then any type of value is acceptable. 
							Other type values MAY be used for custom purposes, but minimal validators of the specification 
							implementation can allow any instance value on unknown type values.
						</t>
						
						<t hangText="Union Types">
							An array of two or more simple type definitions. Each item in the array MUST be a simple type definition or a schema.
							The instance value is valid if it is of the same type as one of the simple type definitions, or valid by one of the schemas, in the array. 
						</t>
					</list>
				</t>
				
				<figure>
					<preamble>For example, a schema that defines if an instance can be a string or a number would be:</preamble>
					<artwork>
<![CDATA[
{
	"type": ["string", "number"]
}
]]></artwork>
				</figure>
			</section>
			
			<section title="properties" anchor="properties">
				<t>This attribute is an object with property definitions that define the valid values of instance object property values. When the instance value is an object, the property values of the instance object MUST conform to the property definitions in this object. In this object, each property definition's value MUST be a schema, and the property's name MUST be the name of the instance property that it defines. The instance property value MUST be valid according to the schema from the property definition. Properties are considered unordered, the order of the instance properties MAY be in any order.</t>
			</section>
			
			<section title="patternProperties">
				<t>This attribute is an object that defines the schema for a set of property names of an object instance. The name of each property of this attribute's object is a regular expression pattern in the ECMA 262/Perl 5 format, while the value is a schema. If the pattern matches the name of a property on the instance object, the value of the instance's property MUST be valid against the pattern name's schema value.</t>
			</section>
			
			<section title="additionalProperties" anchor="additionalProperties">
				<t>This attribute defines a schema for all properties that are not explicitly defined in an object type definition. If specified, the value MUST be a schema or a boolean. If false is provided, no additional properties are allowed beyond the properties defined in the schema. The default value is an empty schema which allows any value for additional properties.</t>
			</section>
			
			<section title="items">
				<t>This attribute defines the allowed items in an instance array, and MUST be a schema or an array of schemas. The default value is an empty schema which allows any value for items in the instance array.</t>
				<t>When this attribute value is a schema and the instance value is an array, then all the items in the array MUST be valid according to the schema.</t>
				<t>When this attribute value is an array of schemas and the instance value is an array, each position in the instance array MUST conform to the schema in the corresponding position for this array. This called tuple typing. When tuple typing is used, additional items are allowed, disallowed, or constrained by the <xref target="additionalItems">"additionalItems"</xref> attribute using the same rules as <xref target="addi